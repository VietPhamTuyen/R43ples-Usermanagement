<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.4 at 2015-09-17 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>r43ples - CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20150917" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                r43ples
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2015-09-17</span>
                  &nbsp;| <span id="projectVersion">Version: 0.8.7</span>
                      </div>
            <div class="xright">                    <a href="./" title="r43ples">r43ples</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                          <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                      <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                                                                                              <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="testapidocs/index.html" title="Test JavaDocs">Test JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="dependency-analysis.html" title="Dependency Analysis">Dependency Analysis</a>
            </li>
                      <li class="none">
                          <a href="xref/index.html" title="Source Xref">Source Xref</a>
            </li>
                      <li class="none">
                          <a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a>
            </li>
                      <li class="none">
            <strong>CPD</strong>
          </li>
                      <li class="none">
                          <a href="pmd.html" title="PMD">PMD</a>
            </li>
                      <li class="none">
                          <a href="taglist.html" title="Tag List">Tag List</a>
            </li>
                      <li class="none">
                          <a href="cobertura/index.html" title="Cobertura Test Coverage">Cobertura Test Coverage</a>
            </li>
              </ul>
        </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section">
<h2>CPD Results<a name="CPD_Results"></a></h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 5.2.3.</p></div>
<div class="section">
<h2>Duplications<a name="Duplications"></a></h2>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/management/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/MergeManagement.html#L159">159</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merge/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merge/MergeManagement.html#L159">159</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		return list;
	}
	
	/**
		 * Create the revision progresses for both branches.
		 * 
		 * @param listA the linked list with all revisions from start revision to target revision of branch A
		 * @param graphNameRevisionProgressA the graph name of the revision progress of branch A
		 * @param uriA the URI of the revision progress of branch A
		 * @param listB the linked list with all revisions from start revision to target revision branch B
		 * @param graphNameRevisionProgressB the graph name of the revision progress of branch B
		 * @param uriB the URI of the revision progress of branch B
		 * @throws InternalErrorException 
		 */
	public static void createRevisionProgresses(LinkedList&lt;String&gt; listA, String graphNameRevisionProgressA, String uriA, LinkedList&lt;String&gt; listB, String graphNameRevisionProgressB, String uriB) throws InternalErrorException {
		logger.info(&quot;Create the revision progress of branch A and B.&quot;);
		
		// Get the common revision
		String commonRevision = null;
		if ((listA.size() &gt; 0) &amp;&amp; (listB.size() &gt; 0)) {
			commonRevision = listA.getFirst();
		} else {
			throw new InternalErrorException(&quot;Revision path contains no revisions.&quot;);
		}

		// Get the revision number of first revision
		logger.info(&quot;Get the revision number of first revision.&quot;);
		String firstRevisionNumber = &quot;&quot;;
		String graphName = &quot;&quot;;

		String query = String.format(
			  &quot;SELECT ?number ?graph %n&quot;
			+ &quot;WHERE { %n&quot;
			+ &quot;	GRAPH &lt;%s&gt; { %n&quot;
			+ &quot;		&lt;%s&gt; &lt;http://eatld.et.tu-dresden.de/rmo#revisionNumber&gt; ?number . %n&quot;
			+ &quot; 	&lt;%s&gt; &lt;http://eatld.et.tu-dresden.de/rmo#revisionOf&gt; ?graph . %n&quot;
			+ &quot;} }&quot;, Config.revision_graph, commonRevision, commonRevision);
		
		ResultSet results = TripleStoreInterfaceSingleton.get().executeSelectQuery(query);
		
		if (results.hasNext()) {
			QuerySolution qs = results.next();
			firstRevisionNumber = qs.getLiteral(&quot;?number&quot;).toString();
			graphName = qs.getResource(&quot;?graph&quot;).toString();
		}
		
		// Get the full graph name of first revision or create full revision graph of first revision
		String fullGraphNameCommonRevision = &quot;&quot;;
		Boolean tempGraphWasCreated = false;
		try {
			fullGraphNameCommonRevision = RevisionManagement.getReferenceGraph(graphName, firstRevisionNumber);
		} catch (InternalErrorException e) {
			// Create a temporary full graph
			fullGraphNameCommonRevision = graphName + &quot;RM-TEMP-REVISION-PROGRESS-FULLGRAPH&quot;;
			RevisionManagement.generateFullGraphOfRevision(graphName, firstRevisionNumber, fullGraphNameCommonRevision);
			tempGraphWasCreated = true;
		}
		
		// Create revision progress of branch A
		createRevisionProgress(listA, fullGraphNameCommonRevision, graphNameRevisionProgressA, uriA);
		
		// Create revision progress of branch A
		createRevisionProgress(listB, fullGraphNameCommonRevision, graphNameRevisionProgressB, uriB);
		
		// Drop the temporary full graph
		if (tempGraphWasCreated) {
			logger.info(&quot;Drop the temporary full graph.&quot;);
			TripleStoreInterfaceSingleton.get().executeUpdateQuery(&quot;DROP SILENT GRAPH &lt;&quot; + fullGraphNameCommonRevision + &quot;&gt;&quot;);
		}
		
	}
	
	
	
	
	
	
	/**
	 * Create the revision progress.
	 * 
	 * @param list the linked list with all revisions from start revision to target revision
	 * @param fullGraphNameCommonRevision the full graph name of the common revision (first revision of path)
	 * @param graphNameRevisionProgress the graph name of the revision progress
	 * @param uri the URI of the revision progress
	 * @throws InternalErrorException 
	 */
	public static void createRevisionProgress(LinkedList&lt;String&gt; list, String fullGraphNameCommonRevision, String graphNameRevisionProgress, String uri) throws InternalErrorException {
		logger.info(&quot;Create the revision progress of &quot; + uri + &quot; in graph &quot; + graphNameRevisionProgress + &quot;.&quot;);
		
		TripleStoreInterfaceSingleton.get().executeUpdateQuery(String.format(&quot;DROP SILENT GRAPH &lt;%s&gt;&quot;, graphNameRevisionProgress));
		TripleStoreInterfaceSingleton.get().executeUpdateQuery(String.format(&quot;CREATE GRAPH  &lt;%s&gt;&quot;, graphNameRevisionProgress));
		Iterator&lt;String&gt; iteList = list.iterator();
		
		if (iteList.hasNext()) {
			String firstRevision = iteList.next();
					
			// Create the initial content
			// insert the content in full graph to RevisionProgress graph.
			// uri =&quot;http://eatld.et.tu-dresden.de/branch-A&quot; or &quot;http://eatld.et.tu-dresden.de/branch-B&quot;
			// rpo:original funktioniert wie object of &lt;%s&gt;
			
			logger.info(&quot;Create the initial content.&quot;);
			String queryInitial = prefixes + String.format(	
				  &quot;INSERT { GRAPH &lt;%s&gt; { %n&quot;
				+ &quot;	&lt;%s&gt; a rpo:RevisionProgress; %n&quot;
				+ &quot;		rpo:original [ %n&quot;
				+ &quot;			rdf:subject ?s ; %n&quot;
				+ &quot;			rdf:predicate ?p ; %n&quot;
				+ &quot;			rdf:object ?o ; %n&quot;
				+ &quot;			rmo:references &lt;%s&gt; %n&quot;
				+ &quot;		] %n&quot;
				+ &quot;} } WHERE { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; %n&quot;
				+ &quot;		{ ?s ?p ?o . } %n&quot;
				+ &quot;}&quot;,graphNameRevisionProgress, uri, firstRevision,  fullGraphNameCommonRevision);
		
			// Execute the query which generates the initial content
			TripleStoreInterfaceSingleton.get().executeUpdateQuery(queryInitial);

			
			// Update content by current add and delete set - remove old entries
			// the content in iteList is the revision path of branchA or branchB
			// revision is revision in branch path except start revision.
			while (iteList.hasNext()) {
				String revision = iteList.next();
				logger.info(&quot;Update content by current add and delete set of revision &quot; + revision + &quot; - remove old entries.&quot;);
				// Get the ADD and DELETE set URIs
				String addSetURI = RevisionManagement.getAddSetURI(revision, Config.revision_graph);
				String deleteSetURI = RevisionManagement.getDeleteSetURI(revision, Config.revision_graph);
				
				if ((addSetURI != null) &amp;&amp; (deleteSetURI != null)) {
					
					// Update the revision progress with the data of the current revision ADD set
					
					// Delete old entries (original)
					
					//graphNameRevisionProcess = graphName + &quot;-RM-REVISION-PROGRESS-A&quot;
					
					//uri = &quot;http://eatld.et.tu-dresden.de/branch-A&quot; or &quot;http://eatld.et.tu-dresden.de/branch-B&quot;
					
					//?blank funktioniert wie eine mittle wert.
					String queryRevision = prefixes + String.format(
						  &quot;DELETE { GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;	&lt;%s&gt; rpo:original ?blank . %n&quot;
						+ &quot;	?blank rdf:subject ?s . %n&quot;
						+ &quot;	?blank rdf:predicate ?p . %n&quot;
						+ &quot;	?blank rdf:object ?o . %n&quot;
						+ &quot;	?blank rmo:references ?revision . %n&quot;
						+ &quot;} } %n&quot;
						+ &quot;WHERE { &quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			&lt;%s&gt; rpo:original ?blank . %n&quot;
						+ &quot;			?blank rdf:subject ?s . %n&quot;
						+ &quot;			?blank rdf:predicate ?p . %n&quot;
						+ &quot;			?blank rdf:object ?o . %n&quot;
						+ &quot;			?blank rmo:references ?revision . %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			?s ?p ?o %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;};&quot;, graphNameRevisionProgress, uri, graphNameRevisionProgress, uri, addSetURI);
					
					queryRevision += &quot;\n&quot;;
					
					// Delete old entries (added)
					queryRevision += String.format(
						  &quot;DELETE { GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;	&lt;%s&gt; rpo:added ?blank . %n&quot;
						+ &quot;	?blank rdf:subject ?s . %n&quot;
						+ &quot;	?blank rdf:predicate ?p . %n&quot;
						+ &quot;	?blank rdf:object ?o . %n&quot;
						+ &quot;	?blank rmo:references ?revision . %n&quot;
						+ &quot;} } %n&quot;
						+ &quot;WHERE { &quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			&lt;%s&gt; rpo:added ?blank . %n&quot;
						+ &quot;			?blank rdf:subject ?s . %n&quot;
						+ &quot;			?blank rdf:predicate ?p . %n&quot;
						+ &quot;			?blank rdf:object ?o . %n&quot;
						+ &quot;			?blank rmo:references ?revision . %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			?s ?p ?o %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;};&quot;, graphNameRevisionProgress, uri, graphNameRevisionProgress, uri, addSetURI);
					
					queryRevision += &quot;\n&quot;;
					
					// Delete old entries (removed)
					queryRevision += String.format(
						  &quot;DELETE { GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;	&lt;%s&gt; rpo:removed ?blank . %n&quot;
						+ &quot;	?blank rdf:subject ?s . %n&quot;
						+ &quot;	?blank rdf:predicate ?p . %n&quot;
						+ &quot;	?blank rdf:object ?o . %n&quot;
						+ &quot;	?blank rmo:references ?revision . %n&quot;
						+ &quot;} } %n&quot;
						+ &quot;WHERE { &quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			&lt;%s&gt; rpo:removed ?blank . %n&quot;
						+ &quot;			?blank rdf:subject ?s . %n&quot;
						+ &quot;			?blank rdf:predicate ?p . %n&quot;
						+ &quot;			?blank rdf:object ?o . %n&quot;
						+ &quot;			?blank rmo:references ?revision . %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			?s ?p ?o %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;};&quot;, graphNameRevisionProgress, uri, graphNameRevisionProgress, uri, addSetURI);
					
					queryRevision += &quot;\n&quot;;
					
					// Insert new entries (added)
					queryRevision += String.format(	
						  &quot;INSERT { GRAPH &lt;%s&gt; {%n&quot;
						+ &quot;	&lt;%s&gt; a rpo:RevisionProgress; %n&quot;
						+ &quot;		rpo:added [ %n&quot;
						+ &quot;			rdf:subject ?s ; %n&quot;
						+ &quot;			rdf:predicate ?p ; %n&quot;
						+ &quot;			rdf:object ?o ; %n&quot;
						+ &quot;			rmo:references &lt;%s&gt; %n&quot;
						+ &quot;		] %n&quot;
						+ &quot;} } WHERE { %n&quot;
						+ &quot;	GRAPH &lt;%s&gt; %n&quot;
						+ &quot;		{ ?s ?p ?o . } %n&quot;
						+ &quot;};&quot;, graphNameRevisionProgress, uri, revision, addSetURI);
					
					queryRevision += &quot;\n \n&quot;;
					
					// Update the revision progress with the data of the current revision DELETE set
					
					// Delete old entries (original)
					queryRevision += String.format(
						  &quot;DELETE { GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;	&lt;%s&gt; rpo:original ?blank . %n&quot;
						+ &quot;	?blank rdf:subject ?s . %n&quot;
						+ &quot;	?blank rdf:predicate ?p . %n&quot;
						+ &quot;	?blank rdf:object ?o . %n&quot;
						+ &quot;	?blank rmo:references ?revision . %n&quot;
						+ &quot;} } %n&quot;
						+ &quot;WHERE { &quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			&lt;%s&gt; rpo:original ?blank . %n&quot;
						+ &quot;			?blank rdf:subject ?s . %n&quot;
						+ &quot;			?blank rdf:predicate ?p . %n&quot;
						+ &quot;			?blank rdf:object ?o . %n&quot;
						+ &quot;			?blank rmo:references ?revision . %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			?s ?p ?o %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;};&quot;, graphNameRevisionProgress, uri, graphNameRevisionProgress, uri, deleteSetURI);
					
					queryRevision += &quot;\n&quot;;
					
					// Delete old entries (added)
					queryRevision += String.format(
						  &quot;DELETE { GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;	&lt;%s&gt; rpo:added ?blank . %n&quot;
						+ &quot;	?blank rdf:subject ?s . %n&quot;
						+ &quot;	?blank rdf:predicate ?p . %n&quot;
						+ &quot;	?blank rdf:object ?o . %n&quot;
						+ &quot;	?blank rmo:references ?revision . %n&quot;
						+ &quot;} } %n&quot;
						+ &quot;WHERE { &quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			&lt;%s&gt; rpo:added ?blank . %n&quot;
						+ &quot;			?blank rdf:subject ?s . %n&quot;
						+ &quot;			?blank rdf:predicate ?p . %n&quot;
						+ &quot;			?blank rdf:object ?o . %n&quot;
						+ &quot;			?blank rmo:references ?revision . %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			?s ?p ?o %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;};&quot;, graphNameRevisionProgress, uri, graphNameRevisionProgress, uri, deleteSetURI);
					
					queryRevision += &quot;\n&quot;;
					
					// Delete old entries (removed)
					queryRevision += String.format(
						  &quot;DELETE { GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;	&lt;%s&gt; rpo:removed ?blank . %n&quot;
						+ &quot;	?blank rdf:subject ?s . %n&quot;
						+ &quot;	?blank rdf:predicate ?p . %n&quot;
						+ &quot;	?blank rdf:object ?o . %n&quot;
						+ &quot;	?blank rmo:references ?revision . %n&quot;
						+ &quot;} } %n&quot;
						+ &quot;WHERE { &quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			&lt;%s&gt; rpo:removed ?blank . %n&quot;
						+ &quot;			?blank rdf:subject ?s . %n&quot;
						+ &quot;			?blank rdf:predicate ?p . %n&quot;
						+ &quot;			?blank rdf:object ?o . %n&quot;
						+ &quot;			?blank rmo:references ?revision . %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;		GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;			?s ?p ?o %n&quot;
						+ &quot;		} %n&quot;
						+ &quot;};&quot;, graphNameRevisionProgress, uri, graphNameRevisionProgress, uri, deleteSetURI);
					
					queryRevision += &quot;\n&quot;;
					
					// Insert new entries (removed)
					queryRevision += String.format(	
						  &quot;INSERT { GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;	&lt;%s&gt; a rpo:RevisionProgress; %n&quot;
						+ &quot;		rpo:removed [ %n&quot;
						+ &quot;			rdf:subject ?s ; %n&quot;
						+ &quot;			rdf:predicate ?p ; %n&quot;
						+ &quot;			rdf:object ?o ; %n&quot;
						+ &quot;			rmo:references &lt;%s&gt; %n&quot;
						+ &quot;		] %n&quot;
						+ &quot;} } WHERE { %n&quot;
						+ &quot;	GRAPH &lt;%s&gt; %n&quot;
						+ &quot;		{ ?s ?p ?o . } %n&quot;
						+ &quot;}&quot;, graphNameRevisionProgress, uri, revision, deleteSetURI);
				
					// Execute the query which updates the revision progress by the current revision
					TripleStoreInterfaceSingleton.get().executeUpdateQuery(queryRevision);

				} else {
					//TODO Error management - is needed when a ADD or DELETE set is not referenced in the current implementation this error should not occur
					logger.error(&quot;ADD or DELETE set of &quot; + revision + &quot;does not exists.&quot;);
				}
				logger.info(&quot;Revision progress was created.&quot;);
			}
		}
	}

	
	/**
	 * Create the difference triple model which contains all differing triples.
	 * 
	 * @param graphName the graph name
	 * @param graphNameDifferenceTripleModel the graph name of the difference triple model
	 * @param graphNameRevisionProgressA the graph name of the revision progress of branch A
	 * @param uriA the URI of the revision progress of branch A
	 * @param graphNameRevisionProgressB the graph name of the revision progress of branch B
	 * @param uriB the URI of the revision progress of branch B
	 * @param uriSDD the URI of the SDD to use
	 */
	public static void createDifferenceTripleModel(String graphName, String graphNameDifferenceTripleModel, String graphNameRevisionProgressA, String uriA, String graphNameRevisionProgressB, String uriB, String uriSDD){
		
		logger.info(&quot;Create the difference triple model&quot;);
		TripleStoreInterfaceSingleton.get().executeUpdateQuery(String.format(&quot;DROP SILENT GRAPH &lt;%s&gt;&quot;, graphNameDifferenceTripleModel));
		TripleStoreInterfaceSingleton.get().executeUpdateQuery(String.format(&quot;CREATE GRAPH  &lt;%s&gt;&quot;, graphNameDifferenceTripleModel));
		
		// Templates for revision A and B
		String sparqlTemplateRevisionA = String.format(
				  &quot;	GRAPH &lt;%s&gt; { %n&quot;
				+ &quot;		&lt;%s&gt; &lt;%s&gt; ?blankA . %n&quot;
				+ &quot;			?blankA rdf:subject ?s . %n&quot;
				+ &quot;			?blankA rdf:predicate ?p . %n&quot;
				+ &quot;			?blankA rdf:object ?o . %n&quot;
				+ &quot;			?blankA rmo:references ?revisionA . %n&quot;
				+ &quot;	} %n&quot;, graphNameRevisionProgressA, uriA, &quot;%s&quot;);
		String sparqlTemplateRevisionB = String.format(
				  &quot;	GRAPH &lt;%s&gt; { %n&quot;
				+ &quot;		&lt;%s&gt; &lt;%s&gt; ?blankB . %n&quot;
				+ &quot;			?blankB rdf:subject ?s . %n&quot;
				+ &quot;			?blankB rdf:predicate ?p . %n&quot;
				+ &quot;			?blankB rdf:object ?o . %n&quot;
				+ &quot;			?blankB rmo:references ?revisionB . %n&quot;
				+ &quot;	} %n&quot;, graphNameRevisionProgressB, uriB, &quot;%s&quot;);

		String sparqlTemplateNotExistsRevisionA = String.format(
				  &quot;FILTER NOT EXISTS { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { %n&quot;
				+ &quot;		&lt;%s&gt; ?everything ?blankA . %n&quot;
				+ &quot;			?blankA rdf:subject ?s . %n&quot;
				+ &quot;			?blankA rdf:predicate ?p . %n&quot;
				+ &quot;			?blankA rdf:object ?o . %n&quot;
				+ &quot;			?blankA rmo:references ?revisionA . %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameRevisionProgressA, uriA);
		
		String sparqlTemplateNotExistsRevisionB = String.format(
				  &quot;FILTER NOT EXISTS { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { %n&quot;
				+ &quot;		&lt;%s&gt; ?everything ?blankB . %n&quot;
				+ &quot;			?blankB rdf:subject ?s . %n&quot;
				+ &quot;			?blankB rdf:predicate ?p . %n&quot;
				+ &quot;			?blankB rdf:object ?o . %n&quot;
				+ &quot;			?blankB rmo:references ?revisionB . %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameRevisionProgressB, uriB);
		
		// Get all structural definitions which are generating differences
		String queryDifferingSD = String.format(
				  &quot;PREFIX sddo: &lt;http://eatld.et.tu-dresden.de/sddo#&gt; %n&quot;
				+ &quot;PREFIX sdd:  &lt;http://eatld.et.tu-dresden.de/sdd#&gt; %n&quot;
				+ &quot;PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt; %n&quot;
				+ &quot;SELECT ?combinationURI ?tripleStateA ?tripleStateB ?conflict ?automaticResolutionState %n&quot;
				+ &quot;WHERE { GRAPH &lt;%s&gt; { %n&quot;
				+ &quot;	&lt;%s&gt; a sddo:StructuralDefinitionGroup ;&quot;
				+ &quot;		sddo:hasStructuralDefinition ?combinationURI .&quot;
				+ &quot;	?combinationURI a sddo:StructuralDefinition ; %n&quot;
				+ &quot;		sddo:hasTripleStateA ?tripleStateA ; %n&quot;
				+ &quot;		sddo:hasTripleStateB ?tripleStateB ; %n&quot;
				+ &quot;		sddo:isConflicting ?conflict ; %n&quot;
				+ &quot;		sddo:automaticResolutionState ?automaticResolutionState . %n&quot;
				+ &quot;} } %n&quot;, Config.sdd_graph, uriSDD);
				
		// Iterate over all differing combination URIs
		ResultSet resultSetDifferences = TripleStoreInterfaceSingleton.get().executeSelectQuery(queryDifferingSD);
		while (resultSetDifferences.hasNext()) {
			QuerySolution qs = resultSetDifferences.next();

			String currentDifferenceCombinationURI = qs.getResource(&quot;?combinationURI&quot;).toString();
			String currentTripleStateA = qs.getResource(&quot;?tripleStateA&quot;).toString();
			String currentTripleStateB = qs.getResource(&quot;?tripleStateB&quot;).toString();
			// Will return an integer value because virtuoso stores boolean internal as integer
			String currentConflictState = qs.getLiteral(&quot;?conflict&quot;).toString();
			// TDB returns boolean value without &quot;&quot; -&gt; add it to use it in the next query correctly
			if (currentConflictState.equals(&quot;true^^http://www.w3.org/2001/XMLSchema#boolean&quot;)) {
				currentConflictState = &quot;\&quot;true\&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;&quot;;
			} else {
				currentConflictState = &quot;\&quot;false\&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;&quot;;
			}
			String currentAutomaticResolutionState = qs.getResource(&quot;?automaticResolutionState&quot;).toString();
			
			String querySelectPart = &quot;SELECT ?s ?p ?o %s %s %n&quot;;
			String sparqlQueryRevisionA = null;
			String sparqlQueryRevisionB = null;			
			
			// A
			if (currentTripleStateA.equals(SDDTripleState.ADDED.getSddRepresentation())) {
				// In revision A the triple was added
				querySelectPart = String.format(querySelectPart, &quot;?revisionA&quot;, &quot;%s&quot;);
				sparqlQueryRevisionA = String.format(sparqlTemplateRevisionA, SDDTripleState.ADDED.getRpoRepresentation());
			} else if (currentTripleStateA.equals(SDDTripleState.DELETED.getSddRepresentation())) {
				// In revision A the triple was deleted
				querySelectPart = String.format(querySelectPart, &quot;?revisionA&quot;, &quot;%s&quot;);
				sparqlQueryRevisionA = String.format(sparqlTemplateRevisionA, SDDTripleState.DELETED.getRpoRepresentation());
			} else if (currentTripleStateA.equals(SDDTripleState.ORIGINAL.getSddRepresentation())) {
				// In revision A the triple is original
				querySelectPart = String.format(querySelectPart, &quot;?revisionA&quot;, &quot;%s&quot;);
				sparqlQueryRevisionA = String.format(sparqlTemplateRevisionA, SDDTripleState.ORIGINAL.getRpoRepresentation());
			} else if (currentTripleStateA.equals(SDDTripleState.NOTINCLUDED.getSddRepresentation())) {
				// In revision A the triple is not included
				querySelectPart = String.format(querySelectPart, &quot;&quot;, &quot;%s&quot;);
				sparqlQueryRevisionA = sparqlTemplateNotExistsRevisionA;
			}
			
			// B
			if (currentTripleStateB.equals(SDDTripleState.ADDED.getSddRepresentation())) {
				// In revision B the triple was added
				querySelectPart = String.format(querySelectPart, &quot;?revisionB&quot;);
				sparqlQueryRevisionB = String.format(sparqlTemplateRevisionB, SDDTripleState.ADDED.getRpoRepresentation());
			} else if (currentTripleStateB.equals(SDDTripleState.DELETED.getSddRepresentation())) {
				// In revision B the triple was deleted
				querySelectPart = String.format(querySelectPart, &quot;?revisionB&quot;);
				sparqlQueryRevisionB = String.format(sparqlTemplateRevisionB, SDDTripleState.DELETED.getRpoRepresentation());
			} else if (currentTripleStateB.equals(SDDTripleState.ORIGINAL.getSddRepresentation())) {
				// In revision B the triple is original
				querySelectPart = String.format(querySelectPart, &quot;?revisionB&quot;);
				sparqlQueryRevisionB = String.format(sparqlTemplateRevisionB, SDDTripleState.ORIGINAL.getRpoRepresentation());
			} else if (currentTripleStateB.equals(SDDTripleState.NOTINCLUDED.getSddRepresentation())) {
				// In revision B the triple is not included
				querySelectPart = String.format(querySelectPart, &quot;&quot;);
				sparqlQueryRevisionB = sparqlTemplateNotExistsRevisionB;
			}
		
			// Concatenated SPARQL query
			String query = String.format(
					prefixes
					+ &quot;%s&quot;
					+ &quot;WHERE { %n&quot;
					+ &quot;%s&quot;
					+ &quot;%s&quot;
					+ &quot;} %n&quot;, querySelectPart, sparqlQueryRevisionA, sparqlQueryRevisionB);
					
			// Iterate over all triples
			ResultSet resultSetTriples = TripleStoreInterfaceSingleton.get().executeSelectQuery(query);
			while (resultSetTriples.hasNext()) {
				QuerySolution qsQuery = resultSetTriples.next();
				
				String subject = qsQuery.getResource(&quot;?s&quot;).toString();
				String predicate = qsQuery.getResource(&quot;?p&quot;).toString();

				// Differ between literal and resource
				String object = &quot;&quot;;
				if (qsQuery.get(&quot;?o&quot;).isLiteral()) {
					object = &quot;\&quot;&quot; + qsQuery.getLiteral(&quot;?o&quot;).toString() + &quot;\&quot;&quot;;
				} else {
					object = &quot;&lt;&quot; + qsQuery.getResource(&quot;?o&quot;).toString() + &quot;&gt;&quot;;
				}
				
				// Create the references A and B part of the query
				String referencesAB = &quot;. %n&quot;;
				if (!currentTripleStateA.equals(SDDTripleState.NOTINCLUDED.getSddRepresentation()) &amp;&amp; !currentTripleStateB.equals(SDDTripleState.NOTINCLUDED.getSddRepresentation())) {
					referencesAB = String.format(
							  &quot;			rpo:referencesA &lt;%s&gt; ; %n&quot;
							+ &quot;			rpo:referencesB &lt;%s&gt; %n&quot;, qsQuery.getResource(&quot;?revisionA&quot;).toString(), 
																qsQuery.getResource(&quot;?revisionB&quot;).toString());
				} else if (currentTripleStateA.equals(SDDTripleState.NOTINCLUDED.getSddRepresentation()) &amp;&amp; !currentTripleStateB.equals(SDDTripleState.NOTINCLUDED.getSddRepresentation())) {
					referencesAB = String.format(
							  &quot;			rpo:referencesB &lt;%s&gt; %n&quot;, qsQuery.getResource(&quot;?revisionB&quot;).toString());
				} else if (!currentTripleStateA.equals(SDDTripleState.NOTINCLUDED.getSddRepresentation()) &amp;&amp; currentTripleStateB.equals(SDDTripleState.NOTINCLUDED.getSddRepresentation())) {
					referencesAB = String.format(
							  &quot;			rpo:referencesA &lt;%s&gt; %n&quot;, qsQuery.getResource(&quot;?revisionA&quot;).toString());
				}
				
				String queryTriple = prefixes + String.format(
						  &quot;INSERT DATA { GRAPH &lt;%s&gt; {%n&quot;
						+ &quot;	&lt;%s&gt; a rpo:DifferenceGroup ; %n&quot;
						+ &quot;	sddo:hasTripleStateA &lt;%s&gt; ; %n&quot;
						+ &quot;	sddo:hasTripleStateB &lt;%s&gt; ; %n&quot;
						+ &quot;	sddo:isConflicting %s ; %n&quot;
						+ &quot;	sddo:automaticResolutionState &lt;%s&gt; ; %n&quot;
						+ &quot;	rpo:hasDifference [ %n&quot;
						+ &quot;		a rpo:Difference ; %n&quot;
						+ &quot;			rpo:hasTriple [ %n&quot;
						+ &quot;				rdf:subject &lt;%s&gt; ; %n&quot;
						+ &quot;				rdf:predicate &lt;%s&gt; ; %n&quot;
						+ &quot;				rdf:object %s %n&quot;
						+ &quot;			] ; %n&quot;
						+ &quot;%s&quot;
						+ &quot;	] . %n&quot;
						+ &quot;} }&quot;, graphNameDifferenceTripleModel, 
									currentDifferenceCombinationURI, 
									currentTripleStateA, 
									currentTripleStateB,
									currentConflictState,
									currentAutomaticResolutionState,
									subject, 
									predicate,
									object,
									referencesAB);
				
				TripleStoreInterfaceSingleton.get().executeUpdateQuery(queryTriple);
			}
		}
	}
	
	
	/**
	 * Create a merged revision.
	 * 
	 * @param graphName the graph name
	 * @param branchNameA the name of branch A
	 * @param branchNameB the name of branch B
	 * @param user the user
	 * @param commitMessage the commit message
	 * @param graphNameDifferenceTripleModel the graph name of the difference triple model
	 * @param graphNameRevisionProgressA the graph name of the revisions progress A
	 * @param uriA the URI A
	 * @param graphNameRevisionProgressB the graph name of the revisions progress B
	 * @param uriB the URI B
	 * @param uriSDD the URI of the SDD
	 * @param type the merge query type
	 * @param triples the triples which are belonging to the current merge query in N-Triple serialization
	 * @return new revision number
	 * @throws InternalErrorException 
	 */
	public static String createMergedRevision(String graphName, String branchNameA, String branchNameB, String user, String commitMessage, String graphNameDifferenceTripleModel, String graphNameRevisionProgressA, String uriA, String graphNameRevisionProgressB, String uriB, String uriSDD, MergeQueryTypeEnum type, String triples) throws InternalErrorException {
		 
		// Create an empty temporary graph which will contain the merged full content
		String graphNameOfMerged = graphName + &quot;-RM-MERGED-TEMP&quot;;
		createNewGraph(graphNameOfMerged);
		
		// Get the full graph name of branch A
		String graphNameOfBranchA = RevisionManagement.getReferenceGraph(graphName, branchNameA);
		// Get the full graph name of branch B
		String graphNameOfBranchB = RevisionManagement.getReferenceGraph(graphName, branchNameB);
		
		if (type.equals(MergeQueryTypeEnum.MANUAL)) {
			// Manual merge query
			RevisionManagement.executeINSERT(graphNameOfMerged, triples);
		} else {	
			// Copy graph B to temporary merged graph
			String queryCopy = String.format(&quot;COPY &lt;%s&gt; TO &lt;%s&gt;&quot;, graphNameOfBranchB, graphNameOfMerged);
			TripleStoreInterfaceSingleton.get().executeUpdateQuery(queryCopy);
			
			// Get the triples from branch A which should be added to/removed from the merged revision
			String triplesToAdd = &quot;&quot;;
			String triplesToDelete = &quot;&quot;;
			
			// Get all difference groups
			String queryDifferenceGroup = prefixes + String.format(
					  &quot;SELECT ?differenceCombinationURI ?automaticResolutionState ?tripleStateA ?tripleStateB ?conflict %n&quot;
					+ &quot;WHERE { GRAPH &lt;%s&gt; { %n&quot;
					+ &quot;	?differenceCombinationURI a rpo:DifferenceGroup ; %n&quot;
					+ &quot;		sddo:automaticResolutionState ?automaticResolutionState ; %n&quot;
					+ &quot;		sddo:hasTripleStateA ?tripleStateA ; %n&quot;
					+ &quot;		sddo:hasTripleStateB ?tripleStateB ; %n&quot;
					+ &quot;		sddo:isConflicting ?conflict . %n&quot;
					+ &quot;} }&quot;, graphNameDifferenceTripleModel);
	
			// Iterate over all difference groups
			ResultSet resultSetDifferenceGroups = TripleStoreInterfaceSingleton.get().executeSelectQuery(queryDifferenceGroup);
			while (resultSetDifferenceGroups.hasNext()) {
				QuerySolution qsCurrentDifferenceGroup = resultSetDifferenceGroups.next();
	
				String currentDifferencGroupURI = qsCurrentDifferenceGroup.getResource(&quot;?differenceCombinationURI&quot;).toString();
				String currentDifferencGroupAutomaticResolutionState = qsCurrentDifferenceGroup.getResource(&quot;?automaticResolutionState&quot;).toString();
//				Currently not needed
//				String currentDifferencGroupTripleStateA = qsCurrentDifferenceGroup.getResource(&quot;?tripleStateA&quot;).toString();
//				String currentDifferencGroupTripleStateB = qsCurrentDifferenceGroup.getResource(&quot;?tripleStateB&quot;).toString();
				boolean currentDifferencGroupConflict = qsCurrentDifferenceGroup.getLiteral(&quot;?conflict&quot;).getBoolean();
				
				// Get all differences (triples) of current difference group
				String queryDifference = prefixes + String.format(
						  &quot;SELECT ?s ?p ?o %n&quot;
						+ &quot;WHERE { GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;	&lt;%s&gt; a rpo:DifferenceGroup ; %n&quot;
						+ &quot;		rpo:hasDifference ?blankDifference . %n&quot;
						+ &quot;	?blankDifference a rpo:Difference ; %n&quot;
						+ &quot;		rpo:hasTriple ?triple . %n&quot;
						+ &quot;	?triple rdf:subject ?s . %n&quot;
						+ &quot;	?triple rdf:predicate ?p . %n&quot;
						+ &quot;	?triple rdf:object ?o . %n&quot;
						+ &quot;} }&quot;, graphNameDifferenceTripleModel, currentDifferencGroupURI);
				
				// Iterate over all differences (triples)
				ResultSet resultSetDifferences = TripleStoreInterfaceSingleton.get().executeSelectQuery(queryDifference);
				while (resultSetDifferences.hasNext()) {
					QuerySolution qsCurrentDifference = resultSetDifferences.next();
					
					String subject = &quot;&lt;&quot; + qsCurrentDifference.getResource(&quot;?s&quot;).toString() + &quot;&gt;&quot;;
					String predicate = &quot;&lt;&quot; + qsCurrentDifference.getResource(&quot;?p&quot;).toString() + &quot;&gt;&quot;;
	
					// Differ between literal and resource
					String object = &quot;&quot;;
					if (qsCurrentDifference.get(&quot;?o&quot;).isLiteral()) {
						object = &quot;\&quot;&quot; + qsCurrentDifference.getLiteral(&quot;?o&quot;).toString() + &quot;\&quot;&quot;;
					} else {
						object = &quot;&lt;&quot; + qsCurrentDifference.getResource(&quot;?o&quot;).toString() + &quot;&gt;&quot;;
					}
					
					if (	type.equals(MergeQueryTypeEnum.AUTO) || 
							type.equals(MergeQueryTypeEnum.COMMON) || 
							(type.equals(MergeQueryTypeEnum.WITH) &amp;&amp; !currentDifferencGroupConflict) ) {
						// MERGE AUTO or common MERGE query
						if (currentDifferencGroupAutomaticResolutionState.equals(SDDTripleState.ADDED.getSddRepresentation())) {
							// Triple should be added
							triplesToAdd += subject + &quot; &quot; + predicate + &quot; &quot; + object + &quot; . \n&quot;;
						} else {
							// Triple should be deleted
							triplesToDelete += subject + &quot; &quot; + predicate + &quot; &quot; + object + &quot; . \n&quot;;
						}
					} else {
						// MERGE WITH query - conflicting triple
						Model model = JenaModelManagement.readNTripleStringToJenaModel(triples);
						// Create ASK query which will check if the model contains the specified triple
						String queryAsk = String.format(
								  &quot;ASK { %n&quot;
								+ &quot; %s %s %s %n&quot;
								+ &quot;}&quot;, subject, predicate, object);
						Query query = QueryFactory.create(queryAsk);
						QueryExecution qe = QueryExecutionFactory.create(query, model);
						boolean resultAsk = qe.execAsk();
						qe.close();
						model.close();
						if (resultAsk) {
							// Model contains the specified triple
							// Triple should be added
							triplesToAdd += subject + &quot; &quot; + predicate + &quot; &quot; + object + &quot; . \n&quot;;
						} else {
							// Triple should be deleted
							triplesToDelete += subject + &quot; &quot; + predicate + &quot; &quot; + object + &quot; . \n&quot;;
						}
					}
				}
				// Update the merged graph
				// Insert triplesToAdd
				RevisionManagement.executeINSERT(graphNameOfMerged, triplesToAdd);
				// Delete triplesToDelete
				RevisionManagement.executeDELETE(graphNameOfMerged, triplesToDelete);
			}
		}
		
		// Calculate the add and delete sets
		
		// Get all added triples (concatenate all triples which are in MERGED but not in A and all triples which are in MERGED but not in B)
		String queryAddedTriples = String.format(
				  &quot;CONSTRUCT {?s ?p ?o} %n&quot;
				+ &quot;WHERE { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	FILTER NOT EXISTS { %n&quot;
				+ &quot;		GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameOfMerged, graphNameOfBranchA);
		
		String addedTriples = TripleStoreInterfaceSingleton.get().executeConstructQuery(queryAddedTriples, FileUtils.langNTriple);
		
		queryAddedTriples = String.format(
				  &quot;CONSTRUCT {?s ?p ?o} %n&quot;
				+ &quot;WHERE { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	FILTER NOT EXISTS { %n&quot;
				+ &quot;		GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameOfMerged, graphNameOfBranchB);

		addedTriples += TripleStoreInterfaceSingleton.get().executeConstructQuery(queryAddedTriples, FileUtils.langNTriple);
		
		// Get all removed triples (concatenate all triples which are in A but not in MERGED and all triples which are in B but not in MERGED)
		String queryRemovedTriples = String.format(
				  &quot;CONSTRUCT {?s ?p ?o} %n&quot;
				+ &quot;WHERE { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	FILTER NOT EXISTS { %n&quot;
				+ &quot;		GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameOfBranchA, graphNameOfMerged);
		
		String removedTriples = TripleStoreInterfaceSingleton.get().executeConstructQuery(queryRemovedTriples, FileUtils.langNTriple);
		
		queryRemovedTriples = String.format(
				  &quot;CONSTRUCT {?s ?p ?o} %n&quot;
				+ &quot;WHERE { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	FILTER NOT EXISTS { %n&quot;
				+ &quot;		GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameOfBranchB, graphNameOfMerged);
		
		removedTriples += TripleStoreInterfaceSingleton.get().executeConstructQuery(queryRemovedTriples, FileUtils.langNTriple);

		// Create list with the 2 predecessors - the order is important - fist item will specify the branch were the new merged revision will be created
		ArrayList&lt;String&gt; usedRevisionNumbers = new ArrayList&lt;String&gt;();
		usedRevisionNumbers.add(branchNameB);
		usedRevisionNumbers.add(branchNameA);
		return RevisionManagement.createNewRevision(graphName, addedTriples, removedTriples, user, commitMessage, usedRevisionNumbers);
	}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/management/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/MergeManagement.html#L73">73</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merge/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merge/MergeManagement.html#L74">74</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			  + &quot;    }&quot;
			  + &quot;}&quot;
			  + &quot;LIMIT 1&quot;,
			  Config.revision_graph, revision1, revision2);
		ResultSet results = TripleStoreInterfaceSingleton.get().executeSelectQuery(query);
		
		if (results.hasNext()) {
			QuerySolution qs = results.next();
			logger.info(&quot;Common revision found.&quot;);
			return qs.getResource(&quot;?revision&quot;).toString();
		}
		
		logger.info(&quot;No common revision could be found.&quot;);
		return null;		
	}
	
	
	/**
	 * Calculate the path from start revision to target revision.
	 * 
	 * @param startRevision the start revision
	 * @param targetRevision the target revision
	 * @return linked list with all revisions from start revision to target revision
	 */
	public static LinkedList&lt;String&gt; getPathBetweenStartAndTargetRevision(String startRevision, String targetRevision) {
		
		logger.info(&quot;Calculate the shortest path from revision &lt;&quot; + startRevision + &quot;&gt; to &lt;&quot; + targetRevision + &quot;&gt; .&quot;);
		String query = String.format(
			  &quot;PREFIX prov: &lt;http://www.w3.org/ns/prov#&gt; %n&quot;
			+ &quot;SELECT DISTINCT ?revision ?previousRevision %n&quot;
			+ &quot;WHERE { %n&quot;
			+ &quot;	GRAPH &lt;%s&gt; { %n&quot;
			+ &quot;		&lt;%s&gt; prov:wasDerivedFrom* ?revision.&quot;
			+ &quot;		?revision prov:wasDerivedFrom* &lt;%s&gt;.&quot;
			+ &quot;		OPTIONAL{?revision prov:wasDerivedFrom ?previousRevision}&quot;
			+ &quot; }&quot;
			+ &quot;}&quot;, Config.revision_graph, targetRevision, startRevision);
		
		HashMap&lt;String, ArrayList&lt;String&gt;&gt; resultMap = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();
		LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();
		
		ResultSet resultSet = TripleStoreInterfaceSingleton.get().executeSelectQuery(query);

		// Path element counter
		int counterLength = 0;
		
		while (resultSet.hasNext()) {
			QuerySolution qs = resultSet.next();
			String resource = qs.getResource(&quot;?revision&quot;).toString();
			String previousResource = null;
			if (qs.getResource(&quot;?previousRevision&quot;) != null) {
				previousResource = qs.getResource(&quot;?previousRevision&quot;).toString();
			}
			
			if (resultMap.containsKey(resource)) {
				resultMap.get(resource).add(previousResource);
			} else {
				ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
				counterLength++;
				arrayList.add(previousResource);
				resultMap.put(resource, arrayList);
			}
		}
		
		// Sort the result map -&gt; sorted list of path elements
		// A merged revision can have two predecessors -&gt; it is important to choose the right predecessor revision according to the selected path
		String currentPathElement = targetRevision;
		for (int i = 0; i &lt; counterLength; i++) {
			list.addFirst(currentPathElement);
			
			// Check if start revision was already reached
			if (currentPathElement.equals(startRevision)) {
				return list;
			}
			
			if (resultMap.get(currentPathElement).size() &gt; 1) {
				if (resultMap.containsKey(resultMap.get(currentPathElement).get(0))) {
					currentPathElement = resultMap.get(currentPathElement).get(0);
				} else {
					currentPathElement = resultMap.get(currentPathElement).get(1);
				}
			} else {
				currentPathElement = resultMap.get(currentPathElement).get(0);
			}
		}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/management/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/MergeManagement.html#L792">792</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/management/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/MergeManagement.html#L994">994</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merge/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merge/MergeManagement.html#L776">776</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>							(type.equals(MergeQueryTypeEnum.WITH) &amp;&amp; !currentDifferencGroupConflict) ) {
						// MERGE AUTO or common MERGE query
						if (currentDifferencGroupAutomaticResolutionState.equals(SDDTripleState.ADDED.getSddRepresentation())) {
							// Triple should be added
							triplesToAdd += subject + &quot; &quot; + predicate + &quot; &quot; + object + &quot; . \n&quot;;
						} else {
							// Triple should be deleted
							triplesToDelete += subject + &quot; &quot; + predicate + &quot; &quot; + object + &quot; . \n&quot;;
						}
					} else {
						// MERGE WITH query - conflicting triple
						Model model = JenaModelManagement.readNTripleStringToJenaModel(triples);
						// Create ASK query which will check if the model contains the specified triple
						String queryAsk = String.format(
								  &quot;ASK { %n&quot;
								+ &quot; %s %s %s %n&quot;
								+ &quot;}&quot;, subject, predicate, object);
						Query query = QueryFactory.create(queryAsk);
						QueryExecution qe = QueryExecutionFactory.create(query, model);
						boolean resultAsk = qe.execAsk();
						qe.close();
						model.close();
						if (resultAsk) {
							// Model contains the specified triple
							// Triple should be added
							triplesToAdd += subject + &quot; &quot; + predicate + &quot; &quot; + object + &quot; . \n&quot;;
						} else {
							// Triple should be deleted
							triplesToDelete += subject + &quot; &quot; + predicate + &quot; &quot; + object + &quot; . \n&quot;;
						}
					}
				}
				// Update the merged graph
				// Insert triplesToAdd
				RevisionManagement.executeINSERT(graphNameOfMerged, triplesToAdd);
				// Delete triplesToDelete
				RevisionManagement.executeDELETE(graphNameOfMerged, triplesToDelete);
			}
		}
		
		// Calculate the add and delete sets
		
		// Get all added triples (concatenate all triples which are in MERGED but not in A and all triples which are in MERGED but not in B)
		String queryAddedTriples = String.format(
				  &quot;CONSTRUCT {?s ?p ?o} %n&quot;
				+ &quot;WHERE { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	FILTER NOT EXISTS { %n&quot;
				+ &quot;		GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameOfMerged, graphNameOfBranchA);
		
		String addedTriples = TripleStoreInterfaceSingleton.get().executeConstructQuery(queryAddedTriples, FileUtils.langNTriple);
		
		queryAddedTriples = String.format(
				  &quot;CONSTRUCT {?s ?p ?o} %n&quot;
				+ &quot;WHERE { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	FILTER NOT EXISTS { %n&quot;
				+ &quot;		GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameOfMerged, graphNameOfBranchB);

		addedTriples += TripleStoreInterfaceSingleton.get().executeConstructQuery(queryAddedTriples, FileUtils.langNTriple);
		
		// Get all removed triples (concatenate all triples which are in A but not in MERGED and all triples which are in B but not in MERGED)
		String queryRemovedTriples = String.format(
				  &quot;CONSTRUCT {?s ?p ?o} %n&quot;
				+ &quot;WHERE { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	FILTER NOT EXISTS { %n&quot;
				+ &quot;		GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameOfBranchA, graphNameOfMerged);
		
		String removedTriples = TripleStoreInterfaceSingleton.get().executeConstructQuery(queryRemovedTriples, FileUtils.langNTriple);
		
		queryRemovedTriples = String.format(
				  &quot;CONSTRUCT {?s ?p ?o} %n&quot;
				+ &quot;WHERE { %n&quot;
				+ &quot;	GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	FILTER NOT EXISTS { %n&quot;
				+ &quot;		GRAPH &lt;%s&gt; { ?s ?p ?o } %n&quot;
				+ &quot;	} %n&quot;
				+ &quot;}&quot;, graphNameOfBranchB, graphNameOfMerged);
		
		removedTriples += TripleStoreInterfaceSingleton.get().executeConstructQuery(queryRemovedTriples, FileUtils.langNTriple);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>de/tud/plt/r43ples/management/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/MergeManagement.html#L726">726</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/management/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/MergeManagement.html#L928">928</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merge/MergeManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merge/MergeManagement.html#L710">710</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		if (type.equals(MergeQueryTypeEnum.MANUAL)) {
			// Manual merge query
			RevisionManagement.executeINSERT(graphNameOfMerged, triples);
		} else {	
			// Copy graph B to temporary merged graph
			String queryCopy = String.format(&quot;COPY &lt;%s&gt; TO &lt;%s&gt;&quot;, graphNameOfBranchB, graphNameOfMerged);
			TripleStoreInterfaceSingleton.get().executeUpdateQuery(queryCopy);
			
			// Get the triples from branch A which should be added to/removed from the merged revision
			String triplesToAdd = &quot;&quot;;
			String triplesToDelete = &quot;&quot;;
			
			// Get all difference groups
			String queryDifferenceGroup = prefixes + String.format(
					  &quot;SELECT ?differenceCombinationURI ?automaticResolutionState ?tripleStateA ?tripleStateB ?conflict %n&quot;
					+ &quot;WHERE { GRAPH &lt;%s&gt; { %n&quot;
					+ &quot;	?differenceCombinationURI a rpo:DifferenceGroup ; %n&quot;
					+ &quot;		sddo:automaticResolutionState ?automaticResolutionState ; %n&quot;
					+ &quot;		sddo:hasTripleStateA ?tripleStateA ; %n&quot;
					+ &quot;		sddo:hasTripleStateB ?tripleStateB ; %n&quot;
					+ &quot;		sddo:isConflicting ?conflict . %n&quot;
					+ &quot;} }&quot;, graphNameDifferenceTripleModel);
	
			// Iterate over all difference groups
			ResultSet resultSetDifferenceGroups = TripleStoreInterfaceSingleton.get().executeSelectQuery(queryDifferenceGroup);
			while (resultSetDifferenceGroups.hasNext()) {
				QuerySolution qsCurrentDifferenceGroup = resultSetDifferenceGroups.next();
	
				String currentDifferencGroupURI = qsCurrentDifferenceGroup.getResource(&quot;?differenceCombinationURI&quot;).toString();
				String currentDifferencGroupAutomaticResolutionState = qsCurrentDifferenceGroup.getResource(&quot;?automaticResolutionState&quot;).toString();
//				Currently not needed
//				String currentDifferencGroupTripleStateA = qsCurrentDifferenceGroup.getResource(&quot;?tripleStateA&quot;).toString();
//				String currentDifferencGroupTripleStateB = qsCurrentDifferenceGroup.getResource(&quot;?tripleStateB&quot;).toString();
				boolean currentDifferencGroupConflict = qsCurrentDifferenceGroup.getLiteral(&quot;?conflict&quot;).getBoolean();
				
				// Get all differences (triples) of current difference group
				String queryDifference = prefixes + String.format(
						  &quot;SELECT ?s ?p ?o %n&quot;
						+ &quot;WHERE { GRAPH &lt;%s&gt; { %n&quot;
						+ &quot;	&lt;%s&gt; a rpo:DifferenceGroup ; %n&quot;
						+ &quot;		rpo:hasDifference ?blankDifference . %n&quot;
						+ &quot;	?blankDifference a rpo:Difference ; %n&quot;
						+ &quot;		rpo:hasTriple ?triple . %n&quot;
						+ &quot;	?triple rdf:subject ?s . %n&quot;
						+ &quot;	?triple rdf:predicate ?p . %n&quot;
						+ &quot;	?triple rdf:object ?o . %n&quot;
						+ &quot;} }&quot;, graphNameDifferenceTripleModel, currentDifferencGroupURI);
				
				// Iterate over all differences (triples)
				ResultSet resultSetDifferences = TripleStoreInterfaceSingleton.get().executeSelectQuery(queryDifference);
				while (resultSetDifferences.hasNext()) {
					QuerySolution qsCurrentDifference = resultSetDifferences.next();
					
					String subject = &quot;&lt;&quot; + qsCurrentDifference.getResource(&quot;?s&quot;).toString() + &quot;&gt;&quot;;
					String predicate = &quot;&lt;&quot; + qsCurrentDifference.getResource(&quot;?p&quot;).toString() + &quot;&gt;&quot;;
	
					// Differ between literal and resource
					String object = &quot;&quot;;
					if (qsCurrentDifference.get(&quot;?o&quot;).isLiteral()) {
						object = &quot;\&quot;&quot; + qsCurrentDifference.getLiteral(&quot;?o&quot;).toString() + &quot;\&quot;&quot;;
					} else {
						object = &quot;&lt;&quot; + qsCurrentDifference.getResource(&quot;?o&quot;).toString() + &quot;&gt;&quot;;
					}
					
					if (	type.equals(MergeQueryTypeEnum.AUTO) || </pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L306">306</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L353">353</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			ProcessManagement.readDifferenceModel(response.getEntity().toString(), differenceModel, format);
			
			
			ProcessManagement.createDifferenceTree(differenceModel, treeList);
			
			ProcessManagement.createTableModel(differenceModel, tableModel);
			
			
			// Save the current revision numbers
			revisionNumberBranchA = RevisionManagement.getRevisionNumber(graphName, branchNameA);
			revisionNumberBranchB = RevisionManagement.getRevisionNumber(graphName, branchNameB);
			
			//create and initialization reportResult
			
			reportResult = ReportManagement.initialReportResult(differenceModel);
			
			// Create the individual models of both branches
			individualModelBranchA = ProcessManagement.createIndividualModelOfRevision(graphName, branchNameA, differenceModel);
			logger.info(&quot;Individual Model A Test : &quot; + individualModelBranchA.getIndividualStructures().keySet().toString());
			Iterator&lt;Entry&lt;String, IndividualStructure&gt;&gt; itEnt = individualModelBranchA.getIndividualStructures().entrySet().iterator();
			while(itEnt.hasNext()){
				Entry&lt;String,IndividualStructure&gt; entryInd = itEnt.next();
				logger.info(&quot;Individual Sturcture Uri Test&quot; + entryInd.getValue().getIndividualUri());
				logger.info(&quot;Individual Sturcture Triples Test&quot; + entryInd.getValue().getTriples().keySet().toString());

				
			}

			individualModelBranchB = ProcessManagement.createIndividualModelOfRevision(graphName, branchNameB, differenceModel);
			logger.info(&quot;Individual Model B Test : &quot; + individualModelBranchB.getIndividualStructures().keySet().toString());

			
			
			// Create the property list of revisions
			propertyList = ProcessManagement.getPropertiesOfRevision(graphName, branchNameA, branchNameB);
			
			Iterator&lt;String&gt; pit = propertyList.iterator();
			while(pit.hasNext()){
				logger.info(&quot;propertyList Test : &quot; + pit.next().toString());
			}

		}else{</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/management/ProcessManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/management/ProcessManagement.html#L646">646</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/management/ProcessManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/management/ProcessManagement.html#L676">676</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>					.getIndividualStructures().get(identiferUri).getTriples().entrySet().iterator();
			while(indIter.hasNext()) {
				Entry&lt;String,TripleIndividualStructure&gt; indEnt = indIter.next();
				
				//get triple
				Triple triple = indEnt.getValue().getTriple();			
				
				String subject = ProcessManagement.convertTripleStringToPrefixTripleString(ProcessManagement.getSubject(triple));
				String predicate = ProcessManagement.convertTripleStringToPrefixTripleString(ProcessManagement.getPredicate(triple));
				String object = ProcessManagement.convertTripleStringToPrefixTripleString(ProcessManagement.getObject(triple));
				
				Iterator&lt;TableRow&gt; itr = TripleRowList.iterator();
				boolean status = true;
				while(itr.hasNext()){
					TableRow tableRow = itr.next();
					if(tableRow.getSubject().equals(subject) &amp;&amp; tableRow.getObject().equals(object) &amp;&amp; tableRow.getPredicate().equals(predicate)) {
						updatedTripleRowList.add(tableRow);
						status = false;
					}				
				}
				if(status == true){
					updatedTripleRowList.add(new TableRow(triple, subject, predicate, object, &quot;--&quot;, 
	                        &quot;--&quot;, &quot;--&quot;, &quot;--&quot;, &quot;--&quot;, &quot;--&quot;,&quot;--&quot;));
				}
			}
			return updatedTripleRowList;
			
		}else if (!individualA.isEmpty()) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/management/Interface.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/Interface.html#L302">302</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/webservice/Endpoint.java</td>
<td><a href="./xref/de/tud/plt/r43ples/webservice/Endpoint.html#L1520">1520</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		MergeResult mresult = new MergeResult(graphName, branchNameA, branchNameB);
		
		if (!RevisionManagement.checkGraphExistence(graphName)){
			logger.error(&quot;Graph &lt;&quot;+graphName+&quot;&gt; does not exist.&quot;);
			throw new InternalErrorException(&quot;Graph &lt;&quot;+graphName+&quot;&gt; does not exist.&quot;);
		}
			
		
		// Check if A and B are different revisions
		if (RevisionManagement.getRevisionNumber(graphName, branchNameA).equals(RevisionManagement.getRevisionNumber(graphName, branchNameB))) {
			// Branches are equal - throw error
			throw new InternalErrorException(&quot;Specified branches are equal: &quot; + sparqlQuery);
		}
		
		// Check if both are terminal nodes
		if (!(RevisionManagement.isBranch(graphName, branchNameA) &amp;&amp; RevisionManagement.isBranch(graphName, branchNameB))) {
			throw new InternalErrorException(&quot;Non terminal nodes were used: &quot; + sparqlQuery);
		}

		
		// Differ between MERGE query with specified SDD and without SDD			
		String usedSDDURI = null;
		if (sdd != null) {
			// Specified SDD
			usedSDDURI = sddURI;
		} else {
			// Default SDD
			// Query the referenced SDD
			String querySDD = String.format(
					  &quot;PREFIX sddo: &lt;http://eatld.et.tu-dresden.de/sddo#&gt; %n&quot;
					+ &quot;PREFIX rmo: &lt;http://eatld.et.tu-dresden.de/rmo#&gt; %n&quot;
					+ &quot;SELECT ?defaultSDD %n&quot;
					+ &quot;WHERE { GRAPH &lt;%s&gt; {	%n&quot;
					+ &quot;	&lt;%s&gt; a rmo:Graph ;%n&quot;
					+ &quot;		sddo:hasDefaultSDD ?defaultSDD . %n&quot;
					+ &quot;} }&quot;, Config.revision_graph, graphName);
			
			ResultSet resultSetSDD = TripleStoreInterfaceSingleton.get().executeSelectQuery(querySDD);
			if (resultSetSDD.hasNext()) {
				QuerySolution qs = resultSetSDD.next();
				usedSDDURI = qs.getResource(&quot;?defaultSDD&quot;).toString();
			} else {
				throw new InternalErrorException(&quot;Error in revision graph! Selected graph &lt;&quot; + graphName + &quot;&gt; has no default SDD referenced.&quot;);
			}
		}

		// Get the common revision with shortest path
		String commonRevision = MergeManagement.getCommonRevisionWithShortestPath(revisionUriA, revisionUriB);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L783">783</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L958">958</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>				if(difference.getResolutionState().equals(ResolutionState.CONFLICT)){
					count ++;
				}
			}
		}
		
		
		reportResult.setConflictsNotApproved(count);
		
		logger.info(&quot;reportresult : &quot;+ reportResult.getConflictsNotApproved());
		
		//test ReportResult:
		logger.info(&quot;reportresult count: &quot;+ reportResult.getConflictsNotApproved() + &quot;--&quot; + reportResult.getDifferencesResolutionChanged());
		// only for test approved difference model
		Iterator&lt;Entry&lt;String, DifferenceGroup&gt;&gt; iterD = differenceModel.getDifferenceGroups().entrySet().iterator();
		while(iterD.hasNext()) {
			Entry&lt;String, DifferenceGroup&gt; entryDG = (Entry&lt;String, DifferenceGroup&gt;) iterD.next();
			DifferenceGroup differ = (DifferenceGroup) entryDG.getValue();
			Iterator&lt;Entry&lt;String, Difference&gt;&gt; iterDIF = differ.getDifferences().entrySet().iterator();
			while(iterDIF.hasNext()){
				Entry&lt;String, Difference&gt; entryDF = iterDIF.next();
				//get triple
				String tripleString = entryDF.getKey();
				Difference difference = entryDF.getValue();
				
				logger.info(&quot;approved difference model: &quot; + tripleString + difference.getTripleResolutionState() + difference.getResolutionState().toString());</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/model/structure/ReportTableRow.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/model/structure/ReportTableRow.html#L37">37</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/model/structure/TableRow.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/model/structure/TableRow.html#L54">54</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	}
	public String getSubject() {
		return subject;
	}
	public void setSubject(String subject) {
		this.subject = subject;
	}
	public String getPredicate() {
		return predicate;
	}
	public void setPredicate(String predicate) {
		this.predicate = predicate;
	}
	public String getObject() {
		return object;
	}
	public void setObject(String object) {
		this.object = object;
	}
	public String getStateA() {
		return stateA;
	}
	public void setStateA(String stateA) {
		this.stateA = stateA;
	}
	public String getStateB() {
		return stateB;
	}
	public void setStateB(String stateB) {
		this.stateB = stateB;
	}
	public String getRevisionA() {
		return revisionA;
	}
	public void setRevisionA(String revisionA) {
		this.revisionA = revisionA;
	}
	public String getRevisionB() {
		return revisionB;
	}
	public void setRevisionB(String revisionB) {
		this.revisionB = revisionB;
	}
	public String getConflicting() {
		return conflicting;
	}
	public void setConflicting(String conflicting) {
		this.conflicting = conflicting;
	}
	public String getAutomaticResolutionState() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L1158">1158</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L1249">1249</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>					Model wholeContentModel = ProcessManagement.getWholeContentOfRevision(graphName, revisionNumberBranchB);
					logger.debug(&quot;Whole model as N-Triples: \n&quot; + ProcessManagement.writeJenaModelToNTriplesString(wholeContentModel));
					
					logger.info(&quot;whole model: &quot; + ProcessManagement.writeJenaModelToNTriplesString(wholeContentModel));

					// Update dataset with local data
					ArrayList&lt;String&gt; list = ProcessManagement.getAllTriplesDividedIntoInsertAndDelete(differenceModel, wholeContentModel);
					
					logger.debug(&quot;INSERT: \n&quot; + list.get(0));
					logger.debug(&quot;DELETE: \n&quot; + list.get(1));
					
					logger.info(&quot;insert Triple: &quot;+list.get(0));
					logger.info(&quot;delete Triple: &quot;+list.get(1));

					
					String updateQueryInsert = String.format(
							  &quot;INSERT DATA { %n&quot;
							+ &quot;	%s %n&quot;
							+ &quot;}&quot;, list.get(0));
					UpdateAction.parseExecute(updateQueryInsert, wholeContentModel);
					
					String updateQueryDelete = String.format(
							  &quot;DELETE DATA { %n&quot;
							+ &quot; %s %n&quot;
							+ &quot;}&quot;, list.get(1));
					UpdateAction.parseExecute(updateQueryDelete, wholeContentModel);
					
					String triples = ProcessManagement.writeJenaModelToNTriplesString(wholeContentModel);
					logger.debug(&quot;Updated model as N-Triples: \n&quot; + triples); 
					
					logger.info(&quot;updated whole model: &quot;+ triples);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L260">260</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/RebaseControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/RebaseControl.html#L491">491</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	public String getThreeWayReportView(String graphName) throws TemplateException, IOException{
		Map&lt;String, Object&gt; scope = new HashMap&lt;String, Object&gt;();
		StringWriter sw = new StringWriter();
		freemarker.template.Template temp = null; 
		String name = &quot;mergingResultView.ftl&quot;;
		try {  
            Configuration cfg = new Configuration();  
            cfg.setClassForTemplateLoading(MergingControl.class, &quot;/templates&quot;);
            temp = cfg.getTemplate(name);  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
		
		if(graphName == null) {
			graphName = commitModel.getGraphName();
		}
		
		scope.put(&quot;graphName&quot;, graphName);
		scope.put(&quot;clientName&quot;, commitModel.getUser());
		scope.put(&quot;commit&quot;, commitModel);
		scope.put(&quot;version&quot;, Endpoint.class.getPackage().getImplementationVersion() );
		scope.put(&quot;git&quot;, GitRepositoryState.getGitRepositoryState());
		
		temp.process(scope,sw);		
		return sw.toString();	
	}
	
	
	/**
	 * get branch information through the graphName
	 * @param graph : name of graph
	 * return branch name*/
	public static String getBranchInformation(String graph) throws IOException {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/RebaseControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/RebaseControl.html#L236">236</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/management/ProcessManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/management/ProcessManagement.html#L1183">1183</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	public ArrayList&lt;String&gt; getManualAddedTriplesAndRemovedTriples() {
		// The result list
		ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
		
		String triplesToInsert = &quot;&quot;;
		String triplesToDelete = &quot;&quot;;
		
		// Iterate over all difference groups
		Iterator&lt;String&gt; iteDifferenceGroups = differenceModel.getDifferenceGroups().keySet().iterator();
		while (iteDifferenceGroups.hasNext()) {
			String differenceGroupKey = iteDifferenceGroups.next();
			DifferenceGroup differenceGroup = differenceModel.getDifferenceGroups().get(differenceGroupKey);
			
			Iterator&lt;String&gt; iteDifferences = differenceGroup.getDifferences().keySet().iterator();
			while (iteDifferences.hasNext()) {
				String differenceKey = iteDifferences.next();
				Difference difference = differenceGroup.getDifferences().get(differenceKey);
				
				// Get the triple state to use
				SDDTripleStateEnum tripleState;
				if (difference.getResolutionState().equals(ResolutionState.RESOLVED)) {
					// Use the approved triple state
					tripleState = difference.getTripleResolutionState();					
				} else {
					// Use the automatic resolution state
					tripleState = differenceGroup.getAutomaticResolutionState();
				}
				
				// Get the triple
				String triple = ProcessManagement.tripleToString( difference.getTriple());					</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/management/Interface.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/Interface.html#L59">59</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/management/QueryManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/management/QueryManagement.html#L32">32</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		String queryM = query;

		Matcher m = patternSelectFromPart.matcher(queryM);
		while (m.find()) {
			String graphName = m.group(&quot;graph&quot;);
			String type = m.group(&quot;type&quot;);
			String revisionNumber = m.group(&quot;revision&quot;).toLowerCase();
			String newGraphName;

			// if no revision number is declared use the MASTER as default
			if (revisionNumber == null) {
				revisionNumber = &quot;master&quot;;
			}
			if (revisionNumber.equalsIgnoreCase(&quot;master&quot;)) {
				// Respond with MASTER revision - nothing to be done - MASTER revisions are already created in the named graphs
				newGraphName = graphName;
			} else {
				if (RevisionManagement.isBranch(graphName, revisionNumber)) {
					newGraphName = RevisionManagement.getReferenceGraph(graphName, revisionNumber);
				} else {
					// Respond with specified revision, therefore the revision must be generated - saved in graph &lt;RM-TEMP-graphName&gt;
					newGraphName = graphName + &quot;-temp&quot;;
					RevisionManagement.generateFullGraphOfRevision(graphName, revisionNumber, newGraphName);
				}
			}

			queryM = m.replaceFirst(type + &quot; &lt;&quot; + newGraphName + &quot;&gt;&quot;);
			m = patternSelectFromPart.matcher(queryM);
			
		}
		String response = TripleStoreInterfaceSingleton.get().executeSelectConstructAskQuery(queryM, format);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L412">412</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L464">464</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L512">512</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		try {  
            Configuration cfg = new Configuration();  
            cfg.setClassForTemplateLoading(MergingControl.class, &quot;/templates&quot;);
            temp = cfg.getTemplate(name);  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
		
		
		if(isRebase){
	 		logger.info(&quot;commitGraphname: &quot; + rebaseControl.getCommitModel().getGraphName());
		 	scope.put(&quot;graphName&quot;, rebaseControl.getCommitModel().getGraphName());	
		 	scope.put(&quot;clientName&quot;, rebaseControl.getCommitModel().getUser());
	 	}else{
	 		logger.info(&quot;commitGraphname: &quot; + commitModel.getGraphName());
		 	scope.put(&quot;graphName&quot;, commitModel.getGraphName());	 
		 	scope.put(&quot;clientName&quot;, commitModel.getUser());
	 	}
		
		
		scope.put(&quot;individualTableList&quot;, createTableModelSemanticEnrichmentAllIndividualsList());</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L944">944</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L1313">1313</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		Iterator&lt;Entry&lt;String, DifferenceGroup&gt;&gt; iterDM = differenceModel.getDifferenceGroups().entrySet().iterator();
		while(iterDM.hasNext()) {
			Entry&lt;String, DifferenceGroup&gt; entryDG = (Entry&lt;String, DifferenceGroup&gt;) iterDM.next();
			DifferenceGroup differ = (DifferenceGroup) entryDG.getValue();
			
			Iterator&lt;Entry&lt;String, Difference&gt;&gt; iterDIF = differ.getDifferences().entrySet().iterator();
			while(iterDIF.hasNext()){
				Entry&lt;String, Difference&gt; entryDF = iterDIF.next();
				//get triple
				String tripleString = entryDF.getKey();
				
				logger.info(&quot;tripleString : &quot;+ tripleString);
				Difference difference = entryDF.getValue();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L797">797</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L972">972</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L1344">1344</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		Iterator&lt;Entry&lt;String, DifferenceGroup&gt;&gt; iterD = differenceModel.getDifferenceGroups().entrySet().iterator();
		while(iterD.hasNext()) {
			Entry&lt;String, DifferenceGroup&gt; entryDG = (Entry&lt;String, DifferenceGroup&gt;) iterD.next();
			DifferenceGroup differ = (DifferenceGroup) entryDG.getValue();
			Iterator&lt;Entry&lt;String, Difference&gt;&gt; iterDIF = differ.getDifferences().entrySet().iterator();
			while(iterDIF.hasNext()){
				Entry&lt;String, Difference&gt; entryDF = iterDIF.next();
				//get triple
				String tripleString = entryDF.getKey();
				Difference difference = entryDF.getValue();
				
				logger.info(&quot;approved difference model: &quot; + tripleString + difference.getTripleResolutionState() + difference.getResolutionState().toString());</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L736">736</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L891">891</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>		Iterator&lt;Entry&lt;String, DifferenceGroup&gt;&gt; iterDM = differenceModel.getDifferenceGroups().entrySet().iterator();
		while(iterDM.hasNext()) {
			Entry&lt;String, DifferenceGroup&gt; entryDG = (Entry&lt;String, DifferenceGroup&gt;) iterDM.next();
			DifferenceGroup differ = (DifferenceGroup) entryDG.getValue();
			boolean conflicting = differ.isConflicting();
			
			SDDTripleStateEnum automaticState = differ.getAutomaticResolutionState();
			Iterator&lt;Entry&lt;String, Difference&gt;&gt; iterDIF = differ.getDifferences().entrySet().iterator();
			while(iterDIF.hasNext()){
				Entry&lt;String, Difference&gt; entryDF = iterDIF.next();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/webservice/Endpoint.java</td>
<td><a href="./xref/de/tud/plt/r43ples/webservice/Endpoint.html#L494">494</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/webservice/Endpoint.java</td>
<td><a href="./xref/de/tud/plt/r43ples/webservice/Endpoint.html#L574">574</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>			}
			
			//for each client, create a mergingControlMap and for each named graph create a mergingControl, first check, if namedgraph exist .
			//first create the mergingcontrol and than create the rebasecontrol
			
			MergingControl mergingControl;
			HashMap&lt;String, MergingControl&gt; mergingControlMap;
			
			if(!clientMap.containsKey(user)){
				mergingControl = new MergingControl();
				// added client
				clientMap.put(user, new HashMap&lt;String, MergingControl&gt;());
				//added named graph
				clientMap.get(user).put(graphName, mergingControl);
			}else if(clientMap.containsKey(user) &amp;&amp; (!clientMap.get(user).containsKey(graphName))) {
				mergingControl = new MergingControl();
				//added named graph
				clientMap.get(user).put(graphName, mergingControl);
			}else{
				mergingControlMap = clientMap.get(user);
				mergingControl = mergingControlMap.get(graphName);
			}
					
			
			mergingControl.setRebaseControl();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L1002">1002</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L1069">1069</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>	public String createReportProcess() throws TemplateException, IOException, ConfigurationException {
		Map&lt;String, Object&gt; scope = new HashMap&lt;String, Object&gt;();
		StringWriter sw = new StringWriter();
		freemarker.template.Template temp = null; 
		String name = &quot;reportView.ftl&quot;;
		try {  
            Configuration cfg = new Configuration();  
            cfg.setClassForTemplateLoading(MergingControl.class, &quot;/templates&quot;);
            temp = cfg.getTemplate(name);  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
		
		
		List&lt;ReportTableRow&gt;  reportTableRowList = ReportManagement.createReportTableRowList(differenceModel) ;
		
		String report = null;
		if(reportResult.getConflictsNotApproved() &gt; 0){
			report = &quot;1&quot;;
		}else {
			report = &quot;0&quot;;
		}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L944">944</a></td></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L1313">1313</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/management/ReportManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/management/ReportManagement.html#L36">36</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		Iterator&lt;Entry&lt;String, DifferenceGroup&gt;&gt; iterDM = differenceModel.getDifferenceGroups().entrySet().iterator();
		while(iterDM.hasNext()) {
			Entry&lt;String, DifferenceGroup&gt; entryDG = (Entry&lt;String, DifferenceGroup&gt;) iterDM.next();
			DifferenceGroup differ = (DifferenceGroup) entryDG.getValue();
			
			Iterator&lt;Entry&lt;String, Difference&gt;&gt; iterDIF = differ.getDifferences().entrySet().iterator();
			while(iterDIF.hasNext()){
				Entry&lt;String, Difference&gt; entryDF = iterDIF.next();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>de/tud/plt/r43ples/management/SampleDataSet.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/SampleDataSet.html#L241">241</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/management/SampleDataSet.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/SampleDataSet.html#L309">309</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>		RevisionManagement.purgeGraph(graphName);
		String revision0 = RevisionManagement.putGraphUnderVersionControl(graphName);

		// Initial commit
		String triples = &quot;&lt;http://example.com/testS&gt; &lt;http://example.com/testP&gt; \&quot;A\&quot;. \n&quot;
				+ &quot;&lt;http://example.com/testS&gt; &lt;http://example.com/testP&gt; \&quot;B\&quot;. \n&quot;
				+ &quot;&lt;http://example.com/testS&gt; &lt;http://example.com/testP&gt; \&quot;C\&quot;. \n&quot;;
		String revision1 = RevisionManagement.createNewRevision(graphName, triples, null, user, &quot;Initial commit&quot;, revision0);
		

		// Create a new branch B1
		DatasetGenerationManagement.createNewBranch(user, &quot;Create a new branch B1&quot;, graphName, revision1, &quot;B1&quot;);

		// Create a new branch B2
		DatasetGenerationManagement.createNewBranch(user, &quot;Create a new branch B2&quot;, graphName, revision1, &quot;B2&quot;);

		// First commit to B1
		String triplesInsert = &quot;&lt;http://example.com/testS&gt; &lt;http://example.com/testP&gt; \&quot;D\&quot;. \n&quot;
				+ &quot;&lt;http://example.com/testS&gt; &lt;http://example.com/testP&gt; \&quot;E\&quot;. \n&quot;;
		String revisionB1_0 = RevisionManagement.createNewRevision(graphName, triplesInsert, null, user, &quot;First commit to B1&quot;, &quot;B1&quot;.toLowerCase());
		

		// First commit to B2
		triplesInsert = &quot;&lt;http://example.com/testS&gt; &lt;http://example.com/testP&gt; \&quot;H\&quot;. \n&quot;;
		String triplesDelete = &quot;&lt;http://example.com/testS&gt; &lt;http://example.com/testP&gt; \&quot;C\&quot;. \n&quot;;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>de/tud/plt/r43ples/management/SparqlRewriter.java</td>
<td><a href="./xref/de/tud/plt/r43ples/management/SparqlRewriter.html#L49">49</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/management/RewriteManagement.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/management/RewriteManagement.html#L52">52</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>	private static final Logger logger = Logger.getLogger(SparqlRewriter.class);

	private static final String rmo = &quot;http://eatld.et.tu-dresden.de/rmo#&quot;;
	private static final String prov = &quot;http://www.w3.org/ns/prov#&quot;;

	private static final Node rmo_Revision = NodeFactory.createURI(rmo + &quot;Revision&quot;);
	private static final Node rmo_deltaRemoved = NodeFactory.createURI(rmo + &quot;deltaRemoved&quot;);
	private static final Node rmo_deltaAdded = NodeFactory.createURI(rmo + &quot;deltaAdded&quot;);
	private static final Node rmo_fullGraph = NodeFactory.createURI(rmo + &quot;fullGraph&quot;);
	private static final Node rmo_references = NodeFactory.createURI(rmo + &quot;references&quot;);
	private static final Node prov_wasDerivedFrom = NodeFactory.createURI(prov + &quot;wasDerivedFrom&quot;);



	/** instance variables */
	private int statement_i = 0;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/RebaseControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/RebaseControl.html#L209">209</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/RebaseControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/RebaseControl.html#L265">265</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>				String triple = ProcessManagement.tripleToString( difference.getTriple());					
				
				// Add the triple to the corresponding string
				if (tripleState.equals(SDDTripleStateEnum.ADDED) || tripleState.equals(SDDTripleStateEnum.ORIGINAL)) {
					triplesToInsert += triple + &quot;%n&quot;;				
				} else if (tripleState.equals(SDDTripleStateEnum.DELETED) || tripleState.equals(SDDTripleStateEnum.NOTINCLUDED)) {
					triplesToDelete += triple + &quot;%n&quot;;
				} else {
					// Error occurred - state was not changed
					logger.error(&quot;Triple state was used which has no internal representation.&quot;);
				}
			}
		}
		
		// Add the string to the result list
		list.add(String.format(triplesToInsert));
		list.add(String.format(triplesToDelete));</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L161">161</a></td></tr>
<tr class="b">
<td>de/tud/plt/r43ples/merging/control/MergingControl.java</td>
<td><a href="./xref/de/tud/plt/r43ples/merging/control/MergingControl.html#L1029">1029</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>	 	}
	 	
	 	if(isRebase){
	 		logger.info(&quot;commitGraphname: &quot; + rebaseControl.getCommitModel().getGraphName());
		 	scope.put(&quot;graphName&quot;, rebaseControl.getCommitModel().getGraphName());
		 	scope.put(&quot;clientName&quot;, rebaseControl.getCommitModel().getUser());
	 	}else{
	 		logger.info(&quot;commitGraphname: &quot; + commitModel.getGraphName());
		 	scope.put(&quot;graphName&quot;, commitModel.getGraphName());	
		 	scope.put(&quot;clientName&quot;, commitModel.getUser());
	 	}
	 	
	 	scope.put(&quot;isRebase&quot;, isRebase);</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2015
                        <a href="http://www.et.tu-dresden.de/ifa/index.php?id=prozessleittechnik">Technische Universität Dresden - Professur für Prozessleittechnik</a>.
            All Rights Reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
